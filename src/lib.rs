// Problem 1: the sum of all the multiples of 3 or 5

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
//
// Find the sum of all the multiples of 3 or 5 below 1000.

pub fn multiples_3_and_5_sum(n: i64) -> i64 {
    let mut v = vec![];
    for i in 1..n {
        if i%3 == 0 || i%5 == 0 {
            // println!("{:?}", i);
            v.push(i);
        }
    }
    v.iter().sum()
}


// Problem 2: Even Fibonacci numbers

// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
//
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

fn fib(n: i64) -> i64 {
    if n < 0 { panic!("{} is negative!", n); }
    match n {
        0     => panic!("zero is not a right argument to fib()!"),
        1     => 1,
        2     =>  2,
        _     => fib(n - 1) + fib(n - 2)
    }
}

pub fn even_fib_nums(n: i64) -> i64 {
    let mut v = vec![];

    if fib(n) > 4000000 { panic!("{} is out of range!", n); }

    for i in 1..n+1{
        let fib_v = fib(i);
        match fib_v % 2 == 0 {
            true => v.push(fib_v),
            _ => ()
        }
    }
    v.iter().sum()
}

// problem3 : Largest prime factor
// 质因数（素因数或质因子）在数论里是指能整除给定正整数的质数

// The prime factors of 13195 are 5, 7, 13 and 29.
//
// What is the largest prime factor of the number 600851475143 ?

fn prime_factors(mut n: i64) -> Vec<i64> {
    let mut v = vec![];

    if n < 2 {
        v
    }else{
        let mut i = 2;
        while i <= n {
            while n%i == 0{
                n = n/i;
                v.push(i);
            }
            i = i + 1;
        }
        v
    }
}

pub fn max_prime_factors(n: i64) -> i64 {
    let v = prime_factors(n);
    *v.iter().max().unwrap()
}

// Problem 4: Largest palindrome product 最大回文数字积

// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
//
// Find the largest palindrome made from the product of two 3-digit numbers.

fn is_palindrome(num: u64) -> bool {
    let s: String = num.to_string();
    let rev_s: String = s.chars().rev().collect::<String>();
    s == rev_s
}

pub fn max_palindrome() -> u64 {
    let mut v = vec![];
    for i in 100..1000{
        for j in 100..1000{
            let product = i*j;
            if is_palindrome(product){
                v.push(product);
            }
        }
    }
    *v.iter().max().unwrap()
}

// Problem 5: Smallest multiple

// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
//
// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

// 纯遍历性能很差
// pub fn smallest_multiple() -> usize {
//     let mut n: usize = 2520;
//
//     let mut min = 0;
//     while min == 0 {
//         let mut v: [bool; 20] = [true; 20];
//         for i in 1..21 {
//             if n % i != 0 {
//                 v[i-1] = false;
//             }
//         }
//         if v.contains(&false) {
//             println!("n: {}", n);
//             n = n+1
//         }else{
//             min = n;
//             println!("min: {}", min);
//         }
//     }
//     min
// }

// 优化：求几个数的最小公倍数。
// 一个整数要能被1-10的所有整数整除，那么就等同于他能被1-10之间的所有素数整除

// 欧几里德算法求两个数的最大公约数
fn gcd(a: u32, b: u32) -> u32 {
    if b == 0 {
        a
    }else{
        gcd(b, a % b)
    }
}

// 求多个数的最大公约数
fn mult_gcd(v: Vec<u32>) -> u32 {
    let a = v[0];
    let b = v[1];
    let mut c = gcd(a, b);
    for i in 0..v.len() {
        c = gcd(c, v[i]);
    }
    c
}

// 最小公倍数
pub fn lcm(v: Vec<u32>) -> u32 {
   let mut x = v[0];
   let mut y = v[1];
   let mut num = gcd(x, y);

   for i in 0..v.len(){
       x = num;
       y = v[i];
       let _gcd = gcd(x, y);
       num = x/_gcd * y/_gcd * _gcd;
   }
   num

}
